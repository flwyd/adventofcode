// Copyright 2021 Google LLC
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

// genday24 generates a Go function implementation of a 2021 Day 24 Advent of
// Code input file.  day24.go calls this generated function.
package main

import (
	"bufio"
	"log"
	"os"
	"strings"
	"text/template"
)

type Instruction struct{ Op, First, Second string }
type Program struct {
	Suffix       string
	SrcFile      string
	Instructions []Instruction
}

var tmpl = template.Must(template.New("program").Parse(
	`// Code generated by go run ./genday24.go {{.SrcFile}}; DO NOT EDIT
package main

func Compute_{{.Suffix}}(input [14]int) (int, [15]int) {
	var i, w, x, y, z int
	var zvals [15]int
{{- range .Instructions}}
	// {{.Op}} {{.First}}{{if .Second}} {{.Second}}{{end}}
{{- if eq .Op "inp"}}
	zvals[i] = z
	{{.First}} = input[i]
	i++
{{- else if eq .Op "add"}}
	{{.First}} += {{.Second}}
{{- else if eq .Op "mul"}}
	{{.First}} *= {{.Second}}
{{- else if eq .Op "div"}}
	{{.First}} /= {{.Second}}
{{- else if eq .Op "mod"}}
	{{.First}} %= {{.Second}}
{{- else if eq .Op "eql"}}
	if {{.First}} == {{.Second}} {
		{{.First}} = 1
	} else {
		{{.First}} = 0
	}
{{- end}}
{{- end}}
	zvals[14] = z
	return z, zvals
}
`))

func main() {
	for _, inname := range os.Args[1:] {
		outname := strings.ReplaceAll(strings.TrimSuffix(inname, ".txt"), ".", "") + ".go"
		log.Printf("Generating %s from %s\n", outname, inname)
		in, err := os.Open(inname)
		if err != nil {
			log.Fatalf("Could not read file %s: %v", inname, err)
		}
		defer in.Close()
		out, err := os.Create(outname)
		if err != nil {
			log.Fatalf("Could not open output file %s: %v", outname, err)
		}
		defer out.Close()
		p := Program{
			Suffix:       strings.TrimSuffix(outname, ".go"),
			SrcFile:      inname,
			Instructions: make([]Instruction, 0),
		}
		s := bufio.NewScanner(in)
		lineno := 0
		for s.Scan() {
			lineno++
			line := strings.Split(s.Text(), " ")
			if len(line) != 3 && (len(line) != 2 || line[0] != "inp") {
				log.Fatalf("Unexpected instruction format %s on line %d", s.Text(), lineno)
			}
			inst := Instruction{Op: line[0], First: line[1]}
			if line[0] != "inp" {
				inst.Second = line[2]
			}
			p.Instructions = append(p.Instructions, inst)
		}
		err = tmpl.Execute(out, p)
	}
}
